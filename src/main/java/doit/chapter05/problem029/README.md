# Problem 029

> BOJ 1920 수 찾기
> <br/>
> [링크](https://www.acmicpc.net/problem/1920)

## 문제

N개의 정수가 주어졌을 때, 이 안에 X라는 정수가 존재하는지 체크하는 문제다.

## 풀이

`이분탐색`과 `Hash`를 사용해 풀이할 수 있다. 두 방식으로 모두 풀이할 것이다.

## 해결 전략

### 이분탐색

- 왼쪽 포인터 `left`와 오른쪽 포인터 `right`를 설정한다.
- `left <= right`일 때까지 반복하여 이분탐색을 수행한다.
- 중간값 `mid`를 설정한다. 오버플로우를 감안해 `(left + right) / 2`가 아닌 `left + (right - left) / 2`로 중간값을 구한다.
- `array[mid]`가 찾는 값이라면 그대로 반환한다.
    - `array[mid]`가 찾는 값보다 크다면 `right`를 `mid-1`로 변경하여 `mid`기준 왼쪽만 탐색한다.
    - `array[mid]`가 찾는 값보다 작다면 `left`를 `mid+1`로 변경하여 `mid`기준 오른쪽만 탐색한다.
- 이분탐색이 마무리되어도 값이 나오지 않았다면 `false`를 반환한다.

이분탐색은 배열을 정렬하는데 `O(N logN)`, 각 값에 대해 이진탐색을 수행하는데 `O(M logN)`이 소요되므로, 시간복잡도는 `O(N logN + M logN)`이다.

### Hash

- `HashMap`을 초기화하고 입력된 N개의 정수를 `key`로, 1을 `value`로 설정한다.
- X 정수가 입력되었을때, `Map.getOrDefault`를 통해 `key`가 존재한다면 `value`를 반환하고, 없다면 0을 반환한다.

`HashMap`에 정수를 담는데 O(N)이 소요되고, 각 값을 `HashMap`에서 탐색하는데 `O(M)`이 소요되므로, 시간복잡도는 `O(N+M)`이다.