# Problem 049

> BOJ 2251 물통
> <br/>
> [링크](https://www.acmicpc.net/problem/2251)

## 문제

3개의 물통 A, B, C가 주어진다. A 물통이 비어있을 때, C 물통의 물이 얼마나 존재하는지를 기록해 출력하는 문제다.

## 풀이

물통간 물이 이동할 수 있는 조합은 총 6가지다.

1. A→B
2. A→C
3. B→A
4. B→C
5. C→A
6. C→B

물통의 형재 상태를 기반으로 물이 이동할 수 있는 모든 조합을 탐색해야한다. 따라서 `BFS` 또는 `DFS`로 풀이할 수 있는데,
depth가 깊어지면 `StackOverFlow` 발생위험이 있고 메모리 사용량이 높은 `DFS` 대신 `BFS`로 풀이할 것이다.

## 해결 전략

- 풀이에 필요한 값을 초기화한다.
    - 물통에서 물이 이동할 수 있는 조합인 `sender`, `receiver` 배열을 선언한다.
    - 물통 A, B의 물의 양을 체크하는 배열 `visited`를 선언한다.
    - 물통 C의 물의 양을 체크하는 TreeSet `result`를 선언한다.
    - 각 물통의 최대 용량을 저장하는 배열 `capacity`를 선언한다.
- `BFS`를 수행하는 메서드를 구현한다.
    - `State`객체를 담는 `Queue`를 생성한다. `State`는 A 물통과 B 물통의 물의 양을 저장하는 변수 a,b로 이루어져 있다.
    - 탐색 시작시 물의 양은 A = 0, B = 0, C = full 이다.
    - 초기 상태를 방문 처리하고, C의 현재 물 양을 `result`에 추가한다.
    - `Queue`에서 현재 상태를 꺼내고, 각 물통의 현재 물 양을 a, b, c로 계산한다.
    - 몰을 옮기는 모든 조합을 탐색하며 `pour`메서드 호출을 통해 다음 상태를 게산한다.
- `pour` 메서드
    - 현재 상태에서 물을 옮긴 결과를 저장할 `next` 배열을 초기화한다.
    - 물을 옮기는 과정을 진행한다.
        - `to`물통에 `from`물통의 물을 추가한다.
        - `to`물통의 용량을 초과하면 초과분을 `from`으로 되돌려 놓는다.
    - 방문하지 않은 상태라면 방문처리하고, `Queue`에 추가한다.
    - 물통 A가 비어있는 상태 `next[0] == 0`이라면 물통 C의 물 양을 `result`에 추가한다.