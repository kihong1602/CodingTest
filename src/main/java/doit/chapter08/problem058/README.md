# Problem 058

> BOJ 1854 K번째 최단경로 찾기
> <br/>
> [링크](https://www.acmicpc.net/problem/1854)

## 문제

N개의 도시와 M개의 간선, 그리고 특정 경로의 K번째 최단 거리를 구하는 문제다.

출발점에서 각 도시로 이동하는 K번째로 짧은 경로의 길이를 구해야 하며, K번째 경로가 존재하지 않으면 -1을 출력한다.

## 풀이

다익스트라 알고리즘을 변형하여 해결할 수 있는 문제다.

K번째 최단 경로를 저장하기 위해 각 도시별로 우선순위 큐를 사용하며, 큐는 K개의 경로만 유지하도록 관리한다.

## 해결 전략

`graph`: 각 도시간 연결정보를 저장하는 인접 리스트
`distance`: 도시 이동시 발생하는 경로 길이를 저장하는 리스트(각 도시는 최대 K개의 경로를 저장)
`PriorityQueue`: 비용이 적은 경로를 우선적으로 탐색하기 위해 사용하는 큐

- 입력값을 기반으로 `graph`와 `distance`를 초기화한다.
    - `distance`는 각 도시에 대해 K개의 경로를 저장하는 역순 우선순위 큐로 초기화한다.
- 출발도시인 1번 노드에서 시작한다.
    - `PriorityQueue`를 생성해, (1번노드, 비용 0)을 시작 노드로 추가한다.
- 큐에서 비용이 가장 낮은 노드를 꺼낸다.
    - 현재 노드가 K번째 경로보다 비용이 높다면 탐색을 건너뛴다.
- 현재 노드의 비용을 `distance[now]`에 추가한다.
    - 큐의 크기가 K를 초과하면 가장 큰 값을 제거해 K개의 경로만 유지한다.
- 현재 노드의 모든 인접 노드를 탐색한다.
    - 새로운 비용(현재 노드 비용 + 간선 비용)이 인접 노드에 저장된 비용보다 작으면, 인접 노드의 비용을 갱신하고 큐에 추가한다.
- 모든 노드에 대해 K번쨰 최단 경로를 출력한다.
    - `distance[node]`의 크기가 K보다 작으면 -1, 아니면 K번째 최단경로 `distance[node].peek()`을 출력한다.