# Problem 047

> BOJ 1325 효율적인 해킹
> <br/>
> [링크](https://www.acmicpc.net/problem/1325)

## 문제

컴퓨터간의 신뢰관계가 주어졌을 때, 한 번의 해킹으로 가장 많은 컴퓨터를 해킹할 수 있는 컴퓨터 번호를 찾는 문제다.

## 풀이

이전에 풀었던 경험이 있는 문제로, 기존에는 `정방향 그래프`와 `DFS`를 사용했지만, 이번에는 시간초과가 발생했다.

테스트 케이스가 추가되면서 더 효율적인 방식이 필요한 것 같다.그래서 `역방향 그래프`와 `BFS`를 사용해 풀이했다.

1. `역방향 그래프`  
   문제에서 A → B라면, B를 해킹하면 A도 해킹할 수 있으므로, 역방향 그래프를 사용해 B에서 시작하는 경로를 찾는다.

2. 방문 배열(`visited`)  
   `visited`는 **2차원 배열**로 선언하여 중복 탐색을 방지하고, 이미 방문한 결과를 재활용한다.
    - `visited[node][i] == true`라면, `node`에서 `i`로 도달 가능한 상태임을 의미한다.

3. `count`   
   특정 노드에서 **도달 가능한 컴퓨터 수**를 기록하는 배열로, BFS를 통해 업데이트한다.
    - 예를 들어, B → A → D라면 `count[B] = 2`.

4. 최대값 갱신:  
   BFS 수행 후, 각 노드의 도달 가능한 최대 컴퓨터 수를 계산하여 갱신한다.

## 해결 전략

1. 그래프 초기화
    - 입력받은 `N`과 `M`에 따라 역방향 그래프를 초기화한다.
    - `count`와 `visited` 배열을 크기 `N+1`로 설정한다.

2. BFS 탐색
    - 각 노드 `i`에 대해 `count[i] == 0`일 때만 BFS를 수행한다.
    - BFS 탐색 중:
        - 현재 노드(`now`)가 이미 방문된 경우(`visited[node][now] == true`) 건너뜀.
        - 도달 가능한 노드 수를 `count[node]++`로 증가시킴.

3. 다음 노드 탐색
    - **`next > node`**:  
      아직 방문하지 않은 노드이므로 큐에 추가한다.
    - **`next <= node`**:  
      이미 탐색된 결과(`visited[next][i]`)를 활용해 `node -> next -> i`로 이어지는 경로를 갱신한다.
        - `visited[node][i] == false`이면서 `visited[next][i] == true`라면:
            - `visited[node][i] = true`, `count[node]++`.

4. 최대값 갱신
    - BFS 종료 시, 최대값을 `max`로 갱신한다.

5. 결과 출력
    - 최대값을 가진 노드를 출력한다.


- **`next > node`**: 새롭게 탐색할 노드.
- **`next <= node`**: 이미 탐색된 결과를 활용해 중복 연산을 줄임.
- 핵심은 **"node -> next -> i로 이어지는 경로를 찾아 방문 가능성을 갱신"**하는 점이다.