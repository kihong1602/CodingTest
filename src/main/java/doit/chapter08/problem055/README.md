# Problem 055

> BOJ 1948 임계 경로
> <br/>
> [링크](https://www.acmicpc.net/problem/1948)

## 문제

모든 도로가 일방 통행이고 사이클이 없는 나라가 있다. 도시 간 연결 관계와 출발, 도착 도시가 주어진다.

지도를 그리는 모든 사람들은 출발 -> 도착 까지의 모든 경로를 탐색한다.

이 때, 도착도시에서 모두 만나는 시간과 1분도 쉬지않고 달려야하는 도로의 수가 몇개 인지 구하는 문제다.

## 풀이

`위상정렬` 알고리즘을 활용해 풀이할 수 있는 문제다.

**일방 통행**이고 **사이클이 없는** 조건에서 방향성 비순환 그래프를 떠올릴 수 있다.

`출발 도시 → 도착 도시`까지의 모든 경로를 탐색하면서

1. 최대 도달 시간 `maxTime`을 구하고,
2. 최대 시간이 걸리는 경로의 수 `필수 경로 수`를 찾는 문제다.

### 해결 전략

`graph`: 도시 간 연결 관계를 저장한 인접 리스트
`reverse`: 도시 간 연결 관계를 **역방향**으로 저장한 인접 리스트 (역방향 탐색용)
`degree`: 각 노드의 진입차수를 저장한 배열
`maxTime`: 각 노드의 최대 도착 시간을 저장하는 배열

1. **그래프 초기화 및 입력 처리**
    - 각 도시간 연결 관계를 `graph`, `reverse`에 저장하고, 진입차수(`degree[to]`)를 증가시킨다.
    - 문제에서 출발 도시와 도착 도시는 항상 연결되어 있음이 보장되므로, 예외 처리 없이 진행 가능하다.

2. **`start -> end`의 최대 시간을 구한다.**
    - `위상정렬`을 통해 `start -> end`까지 걸리는 최대 시간을 계산한다.
    - 각 간선 `edge`에 대해, `maxTime[next] = max(maxTime[next], maxTime[now] + time)`로 갱신한다.
    - 진입차수(`degree[next]`)를 감소시킨 후, 0이라면 `Queue`에 추가한다.
    - 최종적으로, 도착 도시의 최대 도달 시간인 `maxTime[end]`를 반환한다.

3. **`start -> end`까지 최대 시간이 걸리는 경로의 수를 구한다.**
    - 역방향 그래프 `reverse`를 사용하여, 최대 시간이 걸리는 경로만 탐색한다.
    - `maxTime[prev] + time == maxTime[now]` 조건을 만족하는 간선만 `필수 경로`로 간주한다.
    - 이미 방문한 노드(`visited[prev]`)는 중복 계산하지 않도록 처리한다.