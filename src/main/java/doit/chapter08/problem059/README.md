# Problem 059

> BOJ 11657
> <br/>
> [링크](https://www.acmicpc.net/problem/11657)

## 문제

N개의 도시가 있고, 한 도시에서 출발해 다른 도시에 도착하는 버스가 M개 있다.

각 버스는 시작도시 A, 도착도시 B, 도시간 이동시간 C로 나타낼 수 있다.

시간 C가 양수가 아닌 경우가 있고, C = 0은 순간이동, C < 0 은 타임머신으로 시간을 되돌아 가는 경우다.

1번 도시에서 출발해 나머지 도시로 가는 가장 빠른 시간을 구하는 프로그램을 작성하는 문제다.

단, 시간을 무한히 오래전으로 되돌릴 수 있다면 -1만 반환하고, 1번 도시에서 각 도시로 가는 가장 빠른시간을 순서대로 출력하되, 도달할 수 없는 도시는 -1로 출력한다.

## 풀이

가중치가 음수거나, 시간이 무한히 오래전으로 갈 수 있는 음수 사이클이 존재하는 그래프가 그려진다.

즉, 다익스트라 알고리즘 보단 벨만-포드 알고리즘을 사용해 풀이해야 하는 문제다.

## 해결 전략

`Edge`: 각 노드별 시작도시, 출발도시, 가중치를 저장하는 클래스
`graph`: `Edge`를 저장하는 리스트
`distance`: 각 노드별 최단 거리를 저장하는 배열. 시작점인 1번도시는 0, 나머지는 무한대로 초기화한다.

- 입력값에 따라 `graph`와 `distance`를 초기화한다.
- `N-1`번 `graph`를 순회하며 최단경로를 갱신한다.
    - 조건은 `distance[edge.start] != Long.MAX_VALUE && distance[edge.end] > distance[edge.start] + edge.time`이다.
- 음수 사이클이 존재하는지 체크한다.
    - 조건은 최단 경로 갱신조건과 동일하다. 한번이라도 최단경로가 갱신된다면 음수 사이클이 존재함을 의미한다.
    - 음수사이클이 존재한다면 바로 -1을 반환한다.
    - 음수 사이클이 존재하지 않는다면 각 도시별 최단 거리를 `StringBuilder`에 누적한 후 반환한다. 도달할 수 없는 도시는 -1로 처리한다.