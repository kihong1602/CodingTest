# Problem 050

> BOJ 1717 집합의 표현
> <br/>
> [링크](https://www.acmicpc.net/problem/1717)

## 문제

0부터 n까지의 원소를 가진 초기 집합 {0}, {1}, {2}, ..., {n}이 주어진다. 이 집합에 대해 두 가지 연산을 수행하려고 한다.

1. 합집합 연산
    - 두 원소가 같은 집합에 속하도록 합친다.

2. 같은 집합 여부 확인 연산
    - 두 원소가 같은 집합에 속하는지 확인한다.

위 연산을 처리하는 프로그램을 만들고, 2번에 대한 결과를 출력하는 문제다.

## 풀이

주어진 문제는 `유니온 파인드` 알고리즘을 통해 해결할 수 있다. `유니온 파인드`는 서로소 집합을 관리하는 효율적인 자료구조로,
다음 두 연산을 빠르게 수행할 수 있다.

- 합집합 연산 (Union): 두 집합을 하나의 집합으로 합침.
- 같은 집합 여부 확인 연산 (Find): 특정 원소가 속한 집합의 루트를 찾음.

문제에서 최대 `n,m=100,000` 이므로, 경로 압축을 통해 `O(α(n))` 복잡도로 최적화된 `유니온 파인드` 알고리즘을 구현하는 것이 적합하다.
이를 통해 반복되는 쿼리에도 높은 성능을 보장할 수 있다.

## 해결 전략

- `IntStream.rangeClosed(0,n)`을 활용해 각 원소가 자신을 루트로 가리키는 배열 `array`를 생성한다.
- find 연산
    - 특정 원소가 속한 집합의 루트를 찾는 연산이다.
    - 경로 압축을 적용해 트리의 깊이를 줄이는 것이 목표로, 루트 노드가 아닌 경우, 부모 노드의 루트를 재귀적으로 찾아 배열의 값을 갱신한다.
- union 연산
    - 두 원소가 속한 집합을 합치는 연산이다.
    - 두 원소의 루트를 비교한 후, 하나의 집합으로 합친다.
- query 처리
    - `query.split(" ")[0]`(이하 type)에 따라 쿼리를 순차적으로 처리한다.
    - `type = 0`: union 연산 수행
    - `type = 1`: 두 원소가 같은 집합에 속해있는지 판별한다. a, b에 대해 find 연산을 수행하여 같은 루트를 가지고 있는지 확인한 후 결과를 출력한다.
