# Programmers 15

> level2 게임 맵 최단거리
> <br/>
> [링크](https://school.programmers.co.kr/learn/courses/30/lessons/1844)

## 문제

ROR 게임은 두 팀으로 나눠서 진행하며, 상대팀 진영을 먼저 파괴하면 이기는 게임이다. 따라서 각 팀은 상대 팀 진영에 최대한 빨리 도착하는 것이 유리하다.

맵의 상태를 나타내는 배열 `maps`가 주어진다. 캐릭터가 상대팀 진영에 도착하기 위해서 지나가야하는 최소 칸의 개수를 구하는 문제다. 도착할 수 없을 때는 -1을 반환한다.

캐릭터는 (1,1)에 위치하고, 상대방 진영은 (n,m)에 위치해있다.

## 풀이

전형적인 DFS, BFS 문제다. 둘 중 무엇을 사용해 구현해도 되지만, 스택오버플로우 방지를 위해 `BFS`로 구현하겠다.

---
[25/01/03 수정]
방문 배열 `visited`를 선언해 메모리를 사용하는 대신, `maps`배열에 이동 거리를 기록하는 방식으로 로직을 수정하였다. 이를 통해 메모리 사용을 줄이고 코드의 간결성을 높였다.

## 해결 전략

- 주어진 `maps`의 크기를 구하고, 방문 기록을 저장하기 위한 2차원 int 배열 `visited`를 초기화한다.
    - [25/01/03 수정] `visited`배열을 생성하지 않는다.
- 시작점 (0,0)에서 `BFS`를 시작하며, 해당 위치를 방문 했음을 `maps`에 거리 값으로 기록한다.
- 큐를 사용해 현재 위치에서 이동가능한 칸을 `BFS`로 탐색한다.
    - 이동할 칸이 맵의 범위를 벗어나지 않았는지
    - 이동할 칸이 1(이동 가능)인지
    - 방문한 칸의 `maps`값을 이전 칸의 값 +1 로 갱신하며, 최단 거리를 기록한다.
- `BFS` 수행 후, 상대방 진영에 해당하는 위치인 (n-1,m-1)의 값을 확인한다.
    - [25/01/03 수정] 해당 위치의 값이 여전히 초기값 1이라면 도달할 수 없음을 의미하므로 -1을 반환한다.
    - 도달 가능한 경우, 해당 위치의 값(최단 거리)를 반환한다.